// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/MockERC20.sol";
import "../src/AuctionManager.sol";
import "../src/SealedBidAuction.sol";

contract Exploit_CommitReveal_Replay_Impersonation is Test {
    MockERC20 token;
    AuctionManager manager;

    address alice;
    address attacker;
    address beneficiary;

    function setUp() public {
        // deterministic addresses for tests
        alice = address(uint160(uint256(keccak256("alice"))));
        attacker = address(uint160(uint256(keccak256("attacker"))));
        beneficiary = address(0xBEEF);

        // deploy token & manager
        token = new MockERC20("Test Token", "TTK", 1_000_000 ether);
        manager = new AuctionManager();

        // fund alice and attacker with tokens
        token.transfer(alice, 1_000 ether);
        token.transfer(attacker, 1_000 ether);

        // sanity
        assertEq(token.balanceOf(alice), 1_000 ether);
        assertEq(token.balanceOf(attacker), 1_000 ether);
    }

    /// @notice attacker copies commit hash and tries to reveal as a different address.
    /// Expectation: reveal should revert with "commitment mismatch" (or similar) because commit includes bidder address.
    function test_ReplayImpersonationFails() public {
        uint256 commitBlocks = 5;
        uint256 revealBlocks = 5;
        uint256 deposit = 10 ether;

        // create auction via manager
        uint256 commitEnd = block.number + commitBlocks;
        uint256 revealEnd = commitEnd + revealBlocks;
        address auctionAddr = manager.createAuction(
            beneficiary,
            address(token),
            commitEnd,
            revealEnd,
            deposit
        );

        SealedBidAuction auction = SealedBidAuction(payable(auctionAddr));

        // Alice approves auction to pull deposit + bid
        uint256 aliceBid = 100 ether;
        // BUT token.approve must be called from alice; use vm.prank
        vm.prank(alice);
        token.approve(auctionAddr, deposit + aliceBid);

        // Attacker approves too (so attacker could attempt to reveal/pay if allowed)
        vm.prank(attacker);
        token.approve(auctionAddr, deposit + aliceBid);

        // alice creates nonce and commitment
        bytes32 aliceNonce = keccak256(abi.encodePacked("alice-secret"));
        bytes32 commitAlice = keccak256(abi.encodePacked(uint256(aliceBid), alice, aliceNonce));

        // Alice commits (auction contract pulls deposit via transferFrom)
        vm.prank(alice);
        auction.commit(commitAlice);

        // Attacker now copies commitAlice (e.g. observed on-chain) and attempts to reuse same preimage
        // Attacker tries to reveal with the same amount and nonce but msg.sender will be attacker.
	vm.roll(commitEnd + 1);   // move to first block of reveal phase
	assertTrue(block.number > commitEnd && block.number <= revealEnd);

        vm.prank(attacker);
        vm.expectRevert("no commit");
        auction.reveal(aliceBid, aliceNonce);

        // As control: Alice successfully reveals with her preimage
        vm.prank(alice);
        auction.reveal(aliceBid, aliceNonce);

        // Move past reveal window and finalize
        vm.roll(revealEnd + 1);
        auction.finalize();

        // Ensure beneficiary got the funds (alice was winner)
        assertEq(token.balanceOf(beneficiary), aliceBid);

        // alice withdraw shouldn't revert (she is winner, so withdraw would revert)
        vm.prank(alice);
        vm.expectRevert("winner cannot withdraw (funds already paid)");
        auction.withdraw();
    }
}
