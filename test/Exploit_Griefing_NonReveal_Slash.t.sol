// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/MockERC20.sol";
import "../src/AuctionManager.sol";
import "../src/SealedBidAuction.sol";

contract Exploit_Griefing_NonReveal_Slash is Test {
    // Declare the BidRevealed event in the test contract
    event BidRevealed(address indexed bidder, uint256 amount);

    MockERC20 token;
    AuctionManager manager;
    SealedBidAuction auction;
    uint256 commitEnd;
    uint256 revealEnd;

    address deployer = 0x1f9162aDf495696C72Be2473e62C51B7B6fd2E50;
    address alice   = 0x15d34AAf54267DB7D7c367839AAf71A00a2C6A65;
    address attacker = 0x9965507D1a55bcC2695C58ba16FB37d819B0A4dc;
    address beneficiary = 0x099BA97a37FA019c064a2517026e3c2Ea8DB9964;

    uint256 deposit = 10 ether;
    uint256 aliceBid = 100 ether;
    uint256 attackerBid = 90 ether;

    bytes32 aliceNonce;
    bytes32 attackerNonce;

    function setUp() public {
	// Use already-deployed token & manager (set MOCK_TOKEN_ADDR, MANAGER_ADDR in env)
	vm.prank(deployer);
        token = MockERC20(vm.envAddress("MOCK_TOKEN_ADDR"));
        console.log("Initial deployer balance:", token.balanceOf(deployer));
	manager = AuctionManager(vm.envAddress("MANAGER_ADDR"));

	vm.prank(deployer);
        token = new MockERC20("TestToken", "TTK", 1_000_000 * 10**18); 
	console.log("Initial deployer balance:", token.balanceOf(deployer));

        uint256 commitBlocks = 6;
        uint256 revealBlocks = 10;
        uint256 commitEnd = block.number + commitBlocks;
        uint256 revealEnd = commitEnd + revealBlocks;

        // create auction via manager
        address auctionAddr = manager.createAuction(payable(beneficiary), address(token), commitEnd, revealEnd, deposit);
	// assign to the contract-level state var 
	auction = SealedBidAuction(payable(auctionAddr));
	uint256 commitEndBlock = auction.commitEndBlock();
	uint256 revealEndBlock = auction.revealEndBlock();

	console.log("commitEndBlock:", commitEndBlock, "revealEndBlock:", revealEndBlock);


        // nonces for commitments
        aliceNonce = keccak256(abi.encodePacked("alice-secret-grief"));
        attackerNonce = keccak256(abi.encodePacked("attacker-secret-grief"));

        // Fund alice & attacker with tokens (transfer from deployer which has initial supply)
	vm.prank(deployer);
	token.transfer(alice, 1_000 ether);
	console.log("Alice's balance after transfer:", token.balanceOf(alice));
	
	vm.prank(deployer);
	token.transfer(attacker, 1_000 ether);
	console.log("Attacker's balance after transfer:", token.balanceOf(attacker));        

	// Alice & attacker approve auction to pull deposit + bid
        vm.prank(alice);
        token.approve(address(auction), deposit + aliceBid);

        vm.prank(attacker);
        token.approve(address(auction), deposit + attackerBid);
    	}

        function test_nonReveal_leads_to_slash_on_finalize() public {
        // Build commit hashes (must match contract's commit encoding)
	commitEnd = auction.commitEndBlock();
    	revealEnd = auction.revealEndBlock();
        bytes32 commitAlice = keccak256(abi.encodePacked(aliceBid, alice, aliceNonce));
        bytes32 commitAttacker = keccak256(abi.encodePacked(attackerBid, attacker, attackerNonce));

        // Both commit during commit phase
        vm.prank(alice);
        auction.commit(commitAlice);

        vm.prank(attacker);
        auction.commit(commitAttacker);

        // sanity: commitments exist
	assertEq(auction.commitments(alice), keccak256(abi.encodePacked(aliceBid, alice, aliceNonce)));
	assertEq(auction.commitments(attacker), keccak256(abi.encodePacked(attackerBid, attacker, attackerNonce)));



	// Move into reveal phase (first reveal block)
        uint256 commitEnd = auction.commitEndBlock();
        uint256 revealEnd = auction.revealEndBlock();
        console.log("commitEndBlock:", commitEnd, "revealEndBlock:", revealEnd);
	vm.roll(commitEnd + 1);
        assertTrue(block.number > commitEnd && block.number <= revealEnd, "not in reveal phase");

        // Alice reveals honestly (Attacker intentionally does NOT reveal)
        vm.prank(alice);
	// Use expectEmit to assert that the event was emitted correctly
        vm.expectEmit(true, true, false, true, address(auction));
        emit BidRevealed(alice, aliceBid);
        auction.reveal(aliceBid, aliceNonce);
	// Alice's revealed bid must be recorded
        assertEq(auction.revealedBid(alice), aliceBid, "alice revealed bid mismatch");


        // Move past reveal window so finalize is allowed
        vm.roll(revealEnd + 1);
        assertTrue(block.number > revealEnd, "reveal window should be passed");

        // beneficiary balance before finalize
        uint256 benBefore = token.balanceOf(beneficiary);

        // finalize (any address can call - use deployer/test runner)
	vm.prank(deployer);
	auction.finalize();

        uint256 benAfter = token.balanceOf(beneficiary);

	// The deposit of the non-revealer (attacker) should be slashed to the beneficiary
	assertEq(benAfter - benBefore, deposit + aliceBid, "beneficiary did not receive slashed deposit");

	// deposit for attacker should be cleared (slashed)
	assertEq(auction.deposits(attacker), 0, "attacker deposit should be cleared after slash");


    }
}
