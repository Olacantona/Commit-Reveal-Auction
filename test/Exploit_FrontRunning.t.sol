// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "forge-std/Test.sol";
import "../src/MockERC20.sol";
import "../src/AuctionManager.sol";
import "../src/SealedBidAuction.sol";
import "../test/utils/AttackerUtils.s.sol";

contract Exploit_FrontRunning is Test {
    MockERC20 token;
    AuctionManager manager;
    SealedBidAuction auction;

    AttackerUtils utils;

    address deployer = address(this);
    address honestBidder = address(0x1);
    address attackerFrontRunner = address(0x2);

    uint256 commitPhaseDuration = 5;
    uint256 revealPhaseDuration = 5;

    function setUp() public {
        token = new MockERC20("TestToken", "TT", 1_000_000 ether);
        manager = new AuctionManager();
        
	uint256 commitEndBlock = block.number + commitPhaseDuration;                
        uint256 revealEndBlock = commitEndBlock + revealPhaseDuration;             
        uint256 depositAmount = 0;
	

	auction = new SealedBidAuction(
        deployer,             // creator
        deployer,             // beneficiary (send winner funds here for test)
        address(token),       // paymentToken (ERC20)
        commitEndBlock,       // commitEndBlock (absolute)
        revealEndBlock,       // revealEndBlock (absolute)
        depositAmount         // depositAmount
	);

	utils = new AttackerUtils();
	
        token.mint(honestBidder, 1000 ether);
        token.mint(attackerFrontRunner, 1000 ether);

        vm.prank(honestBidder);
        token.approve(address(auction), 1000 ether);

        vm.prank(attackerFrontRunner);
        token.approve(address(auction), 1000 ether);
    }

    function testFrontRunningAfterReveal() public {
        // -------------------------------
        // Commit Phase
        // -------------------------------

	// 1) Commit phase: both actors commit

        bytes32 honestNonce = bytes32(uint256(123));
        bytes32 honestCommit = utils.makeCommitment(100 ether, honestBidder, honestNonce); // utils used here
        
	vm.startPrank(honestBidder);
	auction.commit{value: 0}(honestCommit);
        vm.stopPrank();

	bytes32 attackerNonce = bytes32(uint256(999));
        bytes32 attackerCommit = utils.makeCommitment(120 ether, attackerFrontRunner, attackerNonce); // utils used here

        vm.startPrank(attackerFrontRunner);
	auction.commit{value: 0}(attackerCommit);
        vm.stopPrank();

	bytes32 attackerComm = auction.commitments(attackerFrontRunner);
	emit log_bytes32(attackerComm);

        // -------------------------------
        // Reveal Phase
        // -------------------------------
	vm.roll(block.number + commitPhaseDuration + 1);        

        // Honest bidder reveals first
	
        vm.prank(honestBidder);
	auction.reveal(100 ether, honestNonce);	

        // Attacker tries to "cheat" and reveal a higher bid after honest reveal
        vm.prank(attackerFrontRunner);
	vm.expectRevert(bytes("commitment mismatch"));
	auction.reveal(299 ether, attackerNonce);

	uint256 attackerRevealed = auction.revealedBid(attackerFrontRunner);
	emit log_uint(attackerRevealed);

        // -------------------------------
        // Finalize Phase
        // -------------------------------
	vm.roll(block.number + revealPhaseDuration + 1); 
        auction.finalize();
        
	// -------------------------------
        // Assertions
        // -------------------------------
	address winnerAddr = auction.winner();
	uint256 highestBid = auction.winningBid();
	
	emit log_address(auction.winner());
	emit log_uint(auction.winningBid());

	assertEq(winnerAddr, honestBidder, "Honest bidder should win because attacker cheat failed");	
	assertEq(highestBid, 100 ether, "Highest bid should be 100 (honest reveal)");
	}
	// --------------------------
    	// ATTACKER SIMULATIONS (negative tests) - show explicit malicious attempts and expected results
    	// --------------------------

    	// ATTACKER SIM: 1) attacker tries to reveal someone else's commitment (should revert)
    	function test_AttackerRevealOtherCommitFails() public {
        // Honest commits using utils to compute canonical commitment
        bytes32 honestNonce = bytes32(uint256(111));
        bytes32 honestCommit = utils.makeCommitment(100 ether, honestBidder, honestNonce);

        vm.prank(honestBidder);
	auction.commit{value: 0}(honestCommit);
        
	// Move to reveal phase
        vm.roll(block.number + commitPhaseDuration + 1);

        // ATTACK: attacker tries to reveal using honest's preimage.
        // Because the auction requires msg.sender to match the committed address, this must revert.
        vm.prank(attackerFrontRunner);
	vm.expectRevert(bytes("no commit")); // FIX: direct call to reveal to get nice revert decode
        auction.reveal(100 ether, honestNonce); // this is the attacker replay attempt -> should revert
    	}



	// ATTACKER SIM: 2) attacker tries to reveal a different (inflated) amount than committed -> revert, then reveal correct amount
    	function test_AttackerRevealDifferentAmountFails() public {
        // Attacker commits 120
        bytes32 attackerNonce = bytes32(uint256(999));
        bytes32 attackerCommit = utils.makeCommitment(120 ether, attackerFrontRunner, attackerNonce);

        vm.prank(attackerFrontRunner);
	auction.commit{value: 0}(attackerCommit);
        // Advance to reveal
        vm.roll(block.number + commitPhaseDuration + 1);

        // ATTACK: Attacker tries to reveal 150 (inflated) with same nonce — should revert because preimage doesn't match
        vm.prank(attackerFrontRunner);
        vm.expectRevert(bytes("commitment mismatch"));
        auction.reveal(150 ether, attackerNonce); // this should revert

        // Now reveal correctly (120) — valid path should succeed
        vm.prank(attackerFrontRunner);
	auction.reveal(120 ether, attackerNonce);
    }

    	// ATTACKER SIM: 3) relayer / replay attempt - attacker tries to replay the honest preimage (same as #1 but logs stored commitment)
    	function test_AttackerRelayerReplayFails_and_LogState() public {
        bytes32 honestNonce = bytes32(uint256(555));
        bytes32 honestCommit = utils.makeCommitment(50 ether, honestBidder, honestNonce);

        vm.prank(honestBidder);
        auction.commit{value: 0}(honestCommit);

        // log stored commitment (for debug) - show that commitments mapping was set for honestBidder
        bytes32 stored = auction.commitments(honestBidder);
        emit log_bytes32(stored); // helpful to compare with expected keccak value
        // Advance to reveal
        vm.roll(block.number + commitPhaseDuration + 1);

        // Attacker attempts replay: should revert because msg.sender != honestBidder
        vm.prank(attackerFrontRunner);
        vm.expectRevert(bytes("no commit"));
        auction.reveal(50 ether, honestNonce);

        // Honest reveals successfully
        vm.prank(honestBidder);
        auction.reveal(50 ether, honestNonce);
    	}

    	// ATTACKER SIM: 4) positive control: attacker commits higher and reveals correctly -> attacker wins
    	function test_AttackerValidCommitAndRevealWins() public {
        // Honest commits 100
        bytes32 honestNonce = bytes32(uint256(123));
        bytes32 honestCommit = utils.makeCommitment(100 ether, honestBidder, honestNonce);

        vm.prank(honestBidder);
	 auction.commit{value: 0}(honestCommit);        

        // Attacker commits 200
        bytes32 attackerNonce = bytes32(uint256(111));
        bytes32 attackerCommit = utils.makeCommitment(200 ether, attackerFrontRunner, attackerNonce);

        vm.prank(attackerFrontRunner);
	auction.commit{value: 0}(attackerCommit);

        // Advance to reveal
        vm.roll(block.number + commitPhaseDuration + 1);

        // Honest reveals
        vm.prank(honestBidder);
	auction.reveal(100 ether, honestNonce);

        // Attacker reveals their higher valid bid
        vm.prank(attackerFrontRunner);
	auction.reveal(200 ether, attackerNonce);
        
	// Finalize
        vm.roll(block.number + revealPhaseDuration + 1);
        auction.finalize();

        
	// Attacker should still win if auction allows valid commit reveal sequence
        assertEq(auction.winner(), attackerFrontRunner, "Attacker should win with higher bid");
        assertEq(auction.winningBid(), 200 ether, "Highest bid should be 200");

	// Refund non-winning bidders: honest bidder withdraws
	vm.prank(honestBidder);
	auction.withdraw();
	
        // Check refunds
	uint256 honestBalance = token.balanceOf(honestBidder);
        uint256 attackerBalance = token.balanceOf(attackerFrontRunner);

	assertEq(honestBalance, 1000 ether, "Honest bidder should be refunded / unchanged");
        assertEq(attackerBalance, 1000 ether - 200 ether, "Attacker should pay 120 tokens");
    	}

    	function testFrontRunningRejectedAfterReveal() public {
        // -------------------------------
        // Commit Phase
        // -------------------------------
        bytes32 honestNonce = bytes32(uint256(123));
	bytes32 honestCommit = utils.makeCommitment(100 ether, honestBidder, honestNonce);
	vm.prank(honestBidder);
	auction.commit{value: 0}(honestCommit);

	bytes32 attackerNonce = bytes32(uint256(999));
	bytes32 attackerCommit = utils.makeCommitment(150 ether, attackerFrontRunner, attackerNonce);
        vm.startPrank(attackerFrontRunner);
        auction.commit{value: 0}(attackerCommit);

        uint256 attackerRevealed = auction.revealedBid(attackerFrontRunner);
        emit log_uint(attackerRevealed);
	
	// -------------------------------
        // Warp past commit phase
        // -------------------------------
        vm.roll(block.number + commitPhaseDuration + 1);

        // Honest bidder reveals
        vm.startPrank(honestBidder);
	auction.reveal(100 ether, honestNonce);
        vm.stopPrank();

        // Attacker tries to reveal AFTER reveal phase ends
        vm.roll(block.number + revealPhaseDuration + 1);
        vm.startPrank(attackerFrontRunner);
        vm.expectRevert();
        auction.reveal(150 ether, attackerNonce);
        vm.stopPrank();
    }
}
